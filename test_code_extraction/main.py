import os
import re
import json
import argparse

# Customize these variables as needed.
CATEGORIES = [
    "calculator",
    "contact_book",
    "csv_file_analysis",
    "monitor",
    "frequency_of_word",
    "quiz_game",
    "password_generator",
    "temperature_converter",
    "room_game",
    "weather_app"
]
TESTS_PER_CATEGORY = 10  # Number of tests per category (in your case, 10 => 100 tests total)

def get_code_block_regex(language="python"):
    """
    Returns a compiled regex pattern for extracting code blocks of the specified language.
    """
    return re.compile(fr"```{language}\s*(.*?)\s*```", re.DOTALL)

def find_text_fields(data):
    """
    Recursively search a data structure (dict or list) for any values whose key is 'text'.
    Yields each found text value.
    """
    if isinstance(data, dict):
        for key, value in data.items():
            if key == "text" and isinstance(value, str):
                yield value
            else:
                yield from find_text_fields(value)
    elif isinstance(data, list):
        for item in data:
            yield from find_text_fields(item)

def extract_code_blocks(text, language="python"):
    """
    Given a text string, use a regular expression to extract all code blocks of the specified language.
    """
    code_block_regex = get_code_block_regex(language)
    return code_block_regex.findall(text)

def save_code_blocks(code_blocks, output_dir):
    """
    Save each code block to a new Python file. File names are generated by cycling
    through CATEGORIES with TESTS_PER_CATEGORY files per category.
    If more code blocks are found than expected, extra ones are named with a 'test' prefix.
    """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    for i, code in enumerate(code_blocks):
        # Determine which category to use based on the index.
        cat_index = i // TESTS_PER_CATEGORY
        test_number = (i % TESTS_PER_CATEGORY) + 1

        if cat_index < len(CATEGORIES):
            category = CATEGORIES[cat_index]
            filename = f"{category}_{test_number}.py"
        else:
            # If there are more code blocks than categories * TESTS_PER_CATEGORY, use a fallback name.
            filename = f"test_{i+1}.py"

        filepath = os.path.join(output_dir, filename)
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(code)
        print(f"Saved code block #{i+1} to {filepath}")

def process_json_file(json_path, output_dir, language="python"):
    """
    Load a JSON file, search for text fields, extract code blocks, and save them to separate files.
    """
    with open(json_path, "r", encoding="utf-8") as f:
        try:
            data = json.load(f)
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON in {json_path}: {e}")
            return

    # Gather all code blocks from every "text" field found.
    all_code_blocks = []
    for text in find_text_fields(data):
        code_blocks = extract_code_blocks(text, language)
        if code_blocks:
            print(f"Found {len(code_blocks)} code block(s) in a text field.")
        all_code_blocks.extend(code_blocks)

    if not all_code_blocks:
        print(f"No code blocks found in {json_path}.")
    else:
        print(f"Total code blocks found: {len(all_code_blocks)}")
        save_code_blocks(all_code_blocks, output_dir)

def main():
    parser = argparse.ArgumentParser(
        description="Parse JSON file(s) for 'text' fields and extract Python code blocks into separate files."
    )
    parser.add_argument(
        "json_file",
        help="Path to the JSON file to process."
    )
    parser.add_argument(
        "-o", "--output-dir",
        default="extracted_tests",
        help="Directory to save the extracted Python files (default: extracted_tests)"
    )
    parser.add_argument(
        "-l", "--language",
        default="python",
        help="Programming language to extract code blocks for (default: python)"
    )
    args = parser.parse_args()

    process_json_file(args.json_file, args.output_dir, args.language)

if __name__ == "__main__":
    main()
